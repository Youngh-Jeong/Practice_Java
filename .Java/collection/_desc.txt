제네릭(generic)
 - jdk1.5에서 추가된 문법으로 현재는 필수로 사용되고 있음
 - 입력받을 자료형에 대한 지정을 위해 사용되는 문법
    기본적으로 Object형 즉, 모든 종류의 데이터를 받을 때 사용할 데이터의 자료형을 필요할 때 지정하는 방법
    클래스에 전체적으로 지정하거나, 메소드에 한해 지정하는 방법이 있음

컬렉션 프레임웍(Collection Framework)
 - java.util 패키지에 있는 기능(클래스)들
 - 여러 데이터를 한 번에 저장하는 클래스들을 표준화시킨 설계 및 프로그래밍 방식을 의미
 - 컬렉션 프레임웍에는 Collection을 상속받는 List와 Set, 그리고 Collection을 상속받지 않는 Map의 세 가지가 존재
 - List : 순서가 있는 데이터의 집합으로 데이터의 중복을 허용
 - Set : 순서가 없는 데이터의 집합으로 데이터의 중복을 허용하지 않음
 - Map : 키(key)와 값(value)의 쌍으로 이루어진 데이터 집합
 - 모든 컬렉션들의 입력받는 데이터의 자료형은 기본적으로 Object이다.  
    Object이므로 입력받을 때는 아무 자료형이나 받아도 됨.
    단, 사용시 하위클래스의 메소드를 사용하려면 오버라이딩이나 하위클래스로 형변환을 해야 하므로 불편한 부분이 있음
    오버라이딩은 Object클래스에 존재하는 메소드를 이용해야 하는데 메소드가 얼마 없기 때문에 보통은 하위클래스로의 형변환을 주로 하게 됨

Collection<E> 인터페이스
 - List와 Set의 상위클래스의 역할을 하며, 컬렉션 전체에서 공용으로 사용할 수 있는 메소드가 선언되어 있음
 - 제네릭으로 저장할 데이터의 자료형을 지정할 수 있음
    지정하지 않으면 기본적으로 Object가 지정됨
 - 주요 메소드
리턴		메소드명 및 설명
boolean		add(E e) : 지정된 객체를 저장
boolean		addAll(Collection<? extends E> c) : E를 상속받는 자료형을 가진 Collection의 전부를 저장
void		clear() : 모든 요소들을 삭제
boolean		contains(Object o) : 지정한 객체(o)가 컬렉션에 포함되어 있는지 여부를 리턴
boolean		containsAll(Collection<?> c) : 지정한 컬렉션이 포함되어 있는지 여부
boolean		equals(Object o) : 같은 컬렉션인지 여부
boolean		isEmpty() : 컬렉션이 비어 있는지 여부
Iterator<E>	iterator() : 컬렉션의 Iterator를 리턴
boolean		remove(Object o) : 지정된 객체를 찾아 삭제
boolean		removeAll(Collection<?> c) : 지정된 컬렉션에 포함된 객체들을 삭제
boolean		retainAll(Collection<?> c) : 지정된 컬렉션에 포함된 객체들을 제외한 나머지 삭제
int		size() : 컬렉션에 들어있는 객체의 개수
Object[]	toArray() : 컬렉션에 들어있는 객체들을 Object형 배열로 리턴
<T> T[]		toArray(T[] a) : 지정한 배열(a)에 컬렉션의 객체들을 담아 배열로 리턴


List<E> 인터페이스
 - public interface List<E> extends Collection<E>로 선언된 인터페이스
 - 저장 순서가 유지되면서 중복 데이터를 허용하는 컬렉션
 - 주요 메소드 : Collection에 있는 메소드는 제외
리턴		메소드명 및 설명
void		add(int index, E element) : 지정한 위치(index)에 객체(element)를 삽입
boolean		addAll(int index, Collection<? extends E> c) : 지정한 위치(index)에 E를 상속받는 자료형을 가진 Collection의 전부를 저장
E		get(int index) : 리스트에서 지정한 위치의 객체를 리턴
int		indexOf(Object o) : 리스트에서 지정한 객체의 위치를 리턴, 못찾으면 -1을 리턴
int		lastIndexOf(Object o) : indexOf()와 같으나 뒤에서부터 찾기 시작
ListIterator<E>	listIterator() : 리스트의 ListIterator를 리턴
E		remove(int index) : 지정한 위치의 객체를 삭제한 후 그 객체를 리턴
E		set(int index, E element) : 지정한 위치(index)에 객체(element)를 저장
 : 기존의 객체는 삭제됨
List<E>		subList(int fromIndex, int toIndex) : 리스트를 fromIndex부터 toIndex - 1 까지 잘라내어 List로 리턴


ArrayList<E> 클래스
 - List인터페이스를 implements한 클래스로 컬렉션 프레임웍에서 가장 많이 사용
 - 예전에 Vector를 개선한 것으로 될 수 있으면 Vector가 아닌 ArrayList를 사용해야 함
 - List이므로 저장순서를 기억하며(인덱스 사용), 중복된 데이터를 허용함
 - 생성자
ArrayList() : 기본 크기 10인 ArrayList 생성
ArrayList(Collection<? extends E> c) : 지정된 컬렉션을 이용하여 ArrayList 생성
ArrayList(int initialCapacity) : 지정한 초기용량을 가지는 ArrayList 생성
 : Collection을 상속받는 모든 List와 Set의 컬렉션들이 ArrayList로 생성될 수 있다는 의미

 - 주요 메소드 : Collection과 List에 있는 메소드는 제외
리턴		메소드명 및 설명
void		ensureCapacity(int minCapacity) : minCapacity를 최소 용량으로 지정
void		trimToSize() : 용량을 크기에 맞게 줄여줌

LinkedList<E> 클래스
 - ArrayList 다음으로 많이 사용되는 List 중 하나
 - ArrayList에 비해 데이터의 추가 및 삭제가 빠름 : 변화가 많은 컬렉션일 경우 ArrayList보다 효율적
    데이터를 읽어 들이는 시간(접근 시간)이 느리며, 데이터가 많을수록 접근성은 더 떨어짐
    순차적인 추가/삭제는 오히려 ArrayList가 더 빠름
    데이터의 개수가 변하지 않으면 ArrayList가 더 효율적이고, 변화가 많으면 LinkedList가 효율적
 - 주요 메소드 : Collection과 List에 있는 메소드는 제외 
 -Deque<E>인터페이스의 메소드
리턴		메소드명 및 설명
void		addFirst(E e) : 리스트의 첫 부분에 객체 추가
void		addLast(E e) : 리스트의 끝 부분에 객체 추가
Iterator<E>	descendingIterator() : 내림차순으로 정렬하기 위한 iterator를 리턴
E		getFirst() : 첫번째 요소를 리턴
E		getLast() : 마지막 요소를 리턴 
boolean		offerFirst(E e) : 리스트의 맨 앞에 지정된 객체를 추가
boolean		offerLast(E e) : 리스트의 맨 끝에 지정된 객체를 추가
E		peekFirst() : 리스트의 첫번째 요소를 리턴 - peek()와 동일
E		peekLast() : 리스트의 마지막 요소를 리턴
E		pollFirst() : poll()과 동일
E		pollLast() : 리스트의 마지막 요소를 리턴 - 리스트에서 제거
E		pop() : 리스트의 첫번째 요소를 삭제
void		push(E e) : addFirst와 동일
E		removeFirst() : 리스트의 첫번째 요소를 삭제
E		removeLast() : 리스트의 마지막 요소를 삭제
boolean		removeFirstOccurrence(Object o) : 리스트에서 지정한 객체와 동일한 객체들 중 첫번째를 삭제
boolean		removeLastOccurence(Object o) : 리스트에서 지정한 객체와 동일한 객체들 중 마지막을 삭제


 - Queue<E>인터페이스의 메소드
리턴		메소드명 및 설명
E		element() : 리스트의 첫번째 요소를 리턴
boolean		offer(E e) : 리스트의 끝에 지정된 객체를 추가
E		peek() : 리스트의 첫번째 요소를 리턴 - element와 동일
E		poll() : 리스트의 첫번째 요소를 리턴 - 리스트에서 제거


Stack<E> 클래스
 - Vector를 상속받은 클래스로 처음 저장한 객체가 가장 나중에 나오는 구조로 되어 있다.
 - FILO(First In Last Out) 또는 LIFO(Last In First Out)
 - 생성자
Stack() : 빈 스택 생성
 - 주요 메소드
리턴		메소드 명 및 설명
boolean		empty() : 비어있는지 여부를 리턴
E		peek() : 맨 위에 있는 데이터 리턴, 삭제는 안 함(없을 때 EmptyStackException 발생)
E		pop() : 맨 위에 있는 데이터 리턴, 리턴 후 삭제 (없을 때 EmptyStackException 발생)
E		push(E item) : 스택에 지정한 객체를 저장
int		search(Object o) : 지정된 객체의 위치를 리턴(0이 아닌 1부터 시작), 못 찾으면 -1 리턴

Queue<E> 인터페이스
 - Collection인터페이스를 상속받는 인터페이스로 먼저 저장된 객체가 먼저 나오는 구조
 - FIFO(First In First Out) 또는 LILO(Last In Last Out)
 - Queue를 구현한 클래스인 LinkedList를 이용하여 작업하는 경우가 많다.
 - 생성자와 메소드는 LinkedList의 것을 사용하면 됨(Collection인터페이스의 메소드 포함)



