상속(inheritance)
 - 특정 클래스(하위, sub클래스)에서 다른 클래스(상위, super클래스)에게 멤버(변수, 메소드)들을 상속받는 것
    단, private으로 선언된 멤버도 상속이 되기는 하지만 접근시 간접적으로 접근해야 함
    static멤버도 상속받아 사용가능(하위클래스의 이름으로 접근가능)
 - 자바는 모든 클래스(Object 제외)가 상속을 받고 있는 중임
 - 자바에서의 상속은 코드의 재활용이 목적이 되진 않음
    상속의 이유 : 상속 관계의 클래스들 끼리 공통적인 규약을 만들기 위해
 - 자바에서는 단일상속만을 지원하므로 상위클래스는 하나만 존재함
    타언어(C언어)에서는 다중상속을 지원함
 - 문법
class 하위클래스명 extends 상위클래스명{
   하위클래스생성자 {
      super();
      // 상위클래스의 생성자 호출(반드시 하위클래스의 생성자안에서 상위클래스의 생성자를 호출해야 함)
      // 하위클래스에 생성자가 없으면 자동으로 JVM이 상위클래스의 디폴트 생성자를 호출해줌
   }
}

- 상위클래스형으로 선언한 인스턴스에는 하위클래스의 인스턴스가 들어갈 수 있음
   JVM에 의해 내용은 하위클래스이지만 인식은 상위클래스형으로 인식되어 상위클래스의 메소드만을 사용할 수 있음
   단, 오버라이딩된 메소드의 경우는 예외적으로 하위클래스의 메소드가 실행됨


상속을 위한 관계
 - 특정 조건에 맞는 관계끼리의 클래스들을 상속관계에 놓는다.
 - 문법적으로는 어떠한 관계의 클래스들이라도 상관없지만 자바에서의 상속의 목적에는 위배됨
 - IS-A 관계
    '하위클래스 is a 상위클래스'의 관계가 성립될 때를 의미
    즉, 하위클래스가 상위클래스의 일종일 경우 성립됨
 - HAS-A 관계
    '하위클래스 has a 상위 클래스'의 관계가 성립될 때를 의미
    즉, 하위클래스가 상위클래스를 소유하고 있는 경우 성립됨
    단, 소유하지 않는 경우가 있을 경우 상속에 대해서는 다시 생각해봐야 함
     - 소유하지 않는 경우가 있는지 여부를 판단하여 있다면 상속이 아닌 복합방식으로 표현해야 함
        HASAComposite에서 구현
     - 무리해서 상속으로 표현하면 소유하지 않는 경우의 인스턴스를 표현할 방법이 없음


오버라이딩(overriding)
 - 하위클래스에서 상위클래스의 메소드를 재정의하는 것
    오버로딩과 다르게 선언부는 완전 동일(매개변수도 동일)
 - 하위클래스의 인스턴스를 통해 오버라이딩된 메소드를 호출하면 무조건 하위클래스의 메소드가 실행됨
 